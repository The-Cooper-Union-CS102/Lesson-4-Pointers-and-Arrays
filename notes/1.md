# Pointers to Pointers and Arrays

Just as we can have pointers to characters, integers, and doubles, we can
also have pointers to pointers, or pointers to arrays.  This can be useful
for representing higher dimensional structures like a grid of numbers or
a list of strings.

First we will illustrate with a very simple example of a single integer.

```c
// snippets/multiPointer.c
#include <stdio.h>

int main() {
    int x = 1;
    int *px = &x;
    int **ppx = &px;
    int ***pppx = &ppx;
    printf("x: %d\n", ***pppx);
}
```


```
x: 1
```


See how we first initialize a single pointer as before `*px = &x` but then
we go on to initialize a pointer to that pointer by adding another `*` to the
initialization, and using the reference operator `&` on the ponter itself.
We then repeat this pattern one more time to make a pointer to a pointer
to a pointer, `pppx`.  To get the original value, we must dereference with
the defererence operator `*` three times as done in the `printf` statement.
You could also dereference fewer times if you want one of the references
instead.

We can use this same technique to create an array of strings as shown below.

```c
// snippets/stringArray.c
#include <stdio.h>

int main() {
    char *names[] = {"Cory", "Ross", "Gordon"};
    int n;
    for (n = 0; n < 3; n++) {
        printf("name %d: %s\n", n, names[n]);
    }
}
```


```
name 0: Cory
name 1: Ross
name 2: Gordon
```


Note that by leaving the `[]` empty, the size of the array is automatically
determined by its initialization.  We could have put a value there.  In
particular, we could have put the value `3` as shown below since that
is the size of the array.

```c
// snippets/stringArrayFixed.c
#include <stdio.h>

int main() {
    char *names[3] = {"Cory", "Ross", "Gordon"};
    int n;
    for (n = 0; n < 3; n++) {
        printf("name %d: %s\n", n, names[n]);
    }
}
```


```
name 0: Cory
name 1: Ross
name 2: Gordon
```


More importantly though, we could have also put a larger value which leaves
room for more strings in the future, as the code below demonstrates

```c
// snippets/StringArrayMoreRoom.c
#include <stdio.h>

int main() {
    char *names[4] = {"Cory", "Ross", "Gordon"};
    names[3] = "Deborah";
    int n;
    for (n = 0; n < 4; n++) {
        printf("name %d: %s\n", n, names[n]);
    }
}
```


```
name 0: Cory
name 1: Ross
name 2: Gordon
name 3: Deborah
```


We also didn't need to initialize the array with any names at all, it's just
fine to initialize it as empty and then add strings later as in this example.

```c
// snippets/StringArrayEmpty.c
#include <stdio.h>

int main() {
    char *names[4];
    names[0] = "Cory";
    names[1] = "Ross";
    names[2] = "Gordon";
    names[3] = "Deborah";
    int n;
    for (n = 0; n < 4; n++) {
        printf("name %d: %s\n", n, names[n]);
    }
}
```


```
name 0: Cory
name 1: Ross
name 2: Gordon
name 3: Deborah
```


Note that while very similar, a pointer to string arrays is different than
a pointer to pointers of chars.  For one, the previous methods of
initialization are not legal with a simple pointer to pointers.

```c
// snippets/stringArrayBad.c
#include <stdio.h>

int main() {
    char **names = {"Cory", "Ross", "Gordon"};
    int n;
    for (n = 0; n < 3; n++) {
        printf("name %d: %s\n", n, names[n]);
    }
}
```

```
gcc snippets/stringArrayBad.c
```

```
snippets/stringArrayBad.c:4:21: warning: incompatible pointer types initializing 'char **' with an expression of type 'char [5]' [-Wincompatible-pointer-types]
    char **names = {"Cory", "Ross", "Gordon"};
                    ^~~~~~
snippets/stringArrayBad.c:4:29: warning: excess elements in scalar initializer
    char **names = {"Cory", "Ross", "Gordon"};
                            ^~~~~~
2 warnings generated.

```



In addition, if you initialize a pointer to chars with a string literal
like in the below example, attempting to modify it is illegal and will
result in an error.

```c
// snippets/stringArrayVsPointer1.c
#include <stdio.h>

int main() {
    char arrayString[] = "now is the time";
    char *pointerString = "now is the time";
    // Fine
    arrayString[0] = 'N';
    printf("%s\n", arrayString);
    // Wrong
    pointerString[0] = 'N';
    printf("%s\n", pointerString);
}
```

```
gcc snippets/stringArrayVsPointer1.c
```



However this is only because it is pointing to the string literal which is
read-only.  If you instead switch the string pointer to point to the start of
the string array, as done below, it is fine.

```c
// snippets/stringArrayVsPointer2.c
#include <stdio.h>

int main() {
    char arrayString[] = "now is the time";
    char *pointerString = "now is the time";
    // Fine
    arrayString[0] = 'N';
    printf("%s\n", arrayString);
    // Fine
    pointerString = arrayString;
    pointerString[1] = 'O';
    printf("%s\n", pointerString);
}
```


```
Now is the time
NOw is the time
```


One final difference is that a string pointer can be incremented while the
array cannot, as shown in the following example.

```c
// snippets/stringArrayVsPointer3.c
#include <stdio.h>

int main() {
    char arrayString[] = "now is the time";
    char *pointerString = "now is the time";
    // Fine
    ++pointerString;
    printf("%s\n", pointerString);
    // Wrong
    ++arrayString;
    printf("%s\n", arrayString);
}
```

```
gcc snippets/stringArrayVsPointer3.c
```

```
snippets/stringArrayVsPointer3.c:10:5: error: cannot increment value of type 'char [16]'
    ++arrayString;
    ^ ~~~~~~~~~~~
1 error generated.

```



You should note that whenver you pass an array into a function, it will never
truly receive the array, but a pointer which points to the start of the array.
This applies to all types of arrays, not just character arrays.

### Problem

How can we sort an array of names?

## Command Line Arguments

Now we have enough of a basis to start talking about command line arguments,
because these are mostly handled with string pointers.  It turns out that
in fact, our main function can take arguments, usually denoted by `argc`
and `argv`.  The `argc` argument is the "argument count" meaning the number
of arguments passed by the user.  The `argv` argument is the "argument
vector" meaning an array of actual arguments themselves.  The `argc`
parameter is a simple integer, and the `argv` parameter is a pointer to
character arrays.

Let's take a look at a simple example which simply repeat the inputs,
separated onto different lines.

```c
// snippets/basicIo.c
#include <stdio.h>

int main(int argc, char *argv[]) {
    int n;
    for (n = 0; n < argc; n++) {
        printf("%s", argv[n]);
        if (n < (argc - 1)) {
            printf("\n");
        }
    }
    printf("\n");
}
```


```
./a.out
```


This code is instructive but it isn't very useful.  Let's take a look at
a program that actually takes the inputs and does something useful, a
rudimentary calculator that adds all the inputs.

```c
// snippets/bigSum.c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[]) {
    int n;
    int sum = 0;
    for (n = 1; n < argc; n++) {
        sum += atoi(argv[n]);
    }
    printf("Sum: %d\n", sum);
}
```


```
Sum: 0
```


You can see the code is mostly similar to our basic example of printing
the inputs.  The major difference is that instead of printing the input,
we convert it to an integer by using the built in `atoi` (ascii to integer)
function which comes from the standard library, `stdlib`.  We add it to
our running sum, `sum` and print it at the end.

### Problem

How can sort our inputs and print them back sorted?
